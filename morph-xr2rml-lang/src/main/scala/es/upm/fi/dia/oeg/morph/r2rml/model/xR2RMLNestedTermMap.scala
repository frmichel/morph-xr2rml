package es.upm.fi.dia.oeg.morph.r2rml.model

import org.apache.log4j.Logger
import es.upm.fi.dia.oeg.morph.base.{ Constants, TemplateUtility }
import com.hp.hpl.jena.rdf.model.RDFNode
import com.hp.hpl.jena.rdf.model.Resource
import es.upm.fi.dia.oeg.morph.base.exception.MorphException
import es.upm.fi.dia.oeg.morph.base.path.MixedSyntaxPath

/**
 * A nested term map can be used to qualify terms of an RDF collection or container generated by the parent term map
 * (simple nested term map), e.g.:
 * <code>
 *     	rr:objectMap [
 *   		xrr:reference "$.FullName.FirstNames.*";
 * 			rr:termType xrr:RdfBag;
 *    		xrr:nestedTermMap [
 * 				rr:termType rr:Literal;
 * 				rr:datatype xsd:string;
 *           ];
 * 		];
 * </code>
 *
 * A nested term map can be used to modify the current iteration model by using sub-documents of a JSON document as
 * the root document on which we can apply the nested term map, e.g.:
 * <code>
 *     	rr:objectMap [
 *   		xrr:reference "$.FullName";
 *   		xrr:nestedTermMap [
 * 				rr:template "{$.FirstNames.*} {$.LastName}";
 * 				rr:termType xrr:RdfBag;
 * 				xrr:nestedTermMap [
 * 					rr:termType rr:Literal;
 * 					rr:datatype xsd:string;
 * 				];
 *           ];
 * 		];
 * </code>
 *
 * @author Franck Michel, I3S laboratory
 */
class xR2RMLNestedTermMap(
    /** Type of the parent term map, used to infer the term type if it is not provided explicitly */
    _parentTermMapType: Constants.MorphTermMapType.Value,

    _termMapType: Constants.MorphTermMapType.Value,
    _termType: Option[String],
    _datatype: Option[String],
    _languageTag: Option[String],
    _languageMap: Option[String],

    /** optional nested term map within this nested term map */
    _nestedTermMap: Option[xR2RMLNestedTermMap],

    _refFormulation: String,
    _listPushDown: List[xR2RMLPushDown])
    
        extends AbstractTermMap(_termMapType, _termType, _datatype, _languageTag, _languageMap, _nestedTermMap, _refFormulation, _listPushDown) {

    override val logger = Logger.getLogger(this.getClass().getName());

    override def toString(): String = {
        "NestedTermMap[termMapType: " + termMapType.toString() + " , termType:" + termType + ", datatype:" + datatype + ", language:" + languageTag + ", languageMap:" + languageMap + ", listPushDown:" + listPushDown + "]";
    }
}

object xR2RMLNestedTermMap {
    val logger = Logger.getLogger(this.getClass().getName());

    /**
     * Deduce the type of the nested term map (simple, reference, template) based on its properties
     *
     * @param rdfNode the nested term map node
     * @throws es.upm.fi.dia.oeg.morph.base.exception.MorphException in case the nested term map type cannot be decided
     */
    def extractNestedTermMapType(rdfNode: RDFNode) = {
        rdfNode match {
            case resource: Resource => {
                val templateStmt = resource.getProperty(Constants.R2RML_TEMPLATE_PROPERTY);
                val referenceStmt = resource.getProperty(Constants.xR2RML_REFERENCE_PROPERTY);

                if (templateStmt == null && referenceStmt == null) Constants.MorphTermMapType.SimpleNestedTermMap
                else if (templateStmt != null && referenceStmt == null) Constants.MorphTermMapType.TemplateTermMap
                else if (referenceStmt != null && templateStmt == null) Constants.MorphTermMapType.ReferenceTermMap
                else {
                    val errorMessage = "Invalid nested term map " + resource.getLocalName() + ". Should be either simple, reference or template";
                    logger.error(errorMessage);
                    throw new MorphException(errorMessage);
                }
            }
            case _ => {
                val errorMessage = "Invalid nested term map. Should be either simple, reference or template";
                logger.error(errorMessage);
                throw new MorphException(errorMessage);
            }
        }
    }

    /**
     * Look for a xrr:nestedTermMap property and create an instance of xR2RMLNestedTermMap accordingly.
     *
     * @param parentTermMapType
     * @param rdfNode the current Jena RDF node corresponding to the term map being parsed
     * @param refFormulation
     */
    def extractNestedTermMap(
        parentTermMapType: Constants.MorphTermMapType.Value,
        rdfNode: RDFNode,
        refFormulation: String): Option[xR2RMLNestedTermMap] = {

        rdfNode match {
            case resource: Resource => {
                var ntmStmt = resource.getProperty(Constants.xR2RML_NESTEDTM_PROPERTY);
                if ((ntmStmt != null) && ntmStmt.getObject.isResource) {
                    val ntmRes: Resource = ntmStmt.getObject.asResource

                    val termTypeStmt = ntmRes.getProperty(Constants.R2RML_TERMTYPE_PROPERTY)
                    val termType = if (termTypeStmt == null) None else Some(termTypeStmt.getObject().toString())

                    val datatypeStmt = ntmRes.getProperty(Constants.R2RML_DATATYPE_PROPERTY)
                    val datatype = if (datatypeStmt == null) None else Some(datatypeStmt.getObject().toString())

                    val langStmt = ntmRes.getProperty(Constants.R2RML_LANGUAGE_PROPERTY)
                    val language = if (langStmt == null) None else Some(langStmt.getObject().toString())

                    val langMapStmt = ntmRes.getProperty(Constants.R2RML_LANGUAGE_MAP_PROPERTY)
                    val languageMap = if (langMapStmt == null) None else Some(langMapStmt.getObject().toString())

                    val nestedTermMapType = xR2RMLNestedTermMap.extractNestedTermMapType(ntmRes)

                    val listPushDown = xR2RMLPushDown.extractPushDownTags(ntmRes);

                    // Check if there is a nested term map WITHIN this nested term map
                    val nestedTermMap = extractNestedTermMap(nestedTermMapType, ntmRes, refFormulation)

                    val ntm = new xR2RMLNestedTermMap(parentTermMapType, nestedTermMapType, termType, datatype, language, languageMap, nestedTermMap, refFormulation, listPushDown)
                    ntm.parse(ntmRes)

                    if (logger.isTraceEnabled()) logger.trace("Created nested term map: " + ntm)
                    Some(ntm)
                } else None
            }
            case _ => { None }
        }
    }
}
